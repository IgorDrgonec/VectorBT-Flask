---
title: Synthetic
icon: material/creation
---

# :material-creation: Synthetic

Synthetic data is data that might have been generated by financial markets but was not. Synthetic 
price and return data address the financial small data problem and have numerous uses, including testing 
new investment strategies and feeding data-hungry ML models. They also help us to detect behavior and 
outlier discrepancies between real and mimicked markets. For example, if our model performs well on a 
subset of real-world data, we can check it against synthetic data to find out whether we introduced
the look-ahead bias or any other Achilles' heel to our model without knowing it.

To assist us in generating synthetic data, vectorbt implements the class 
[SyntheticData](/api/data/custom/#vectorbtpro.data.custom.SyntheticData), which takes the start date,
the end date, and the frequency, and builds a datetime-like Pandas Index. It then calls the abstract
class method [SyntheticData.generate_symbol](/api/data/custom/#vectorbtpro.data.custom.SyntheticData.generate_symbol),
which takes the symbol and the index, generates new data, and returns a Series or a DataFrame ready to be 
consumed by [Data](/api/data/custom/#vectorbtpro.data.base.Data). We must override this method and implement 
our own data generation logic.

There are two preset classes: [RandomData](/api/data/custom/#vectorbtpro.data.custom.RandomData), which
uses cumulative normally-distributed returns, and [GBMData](/api/data/custom/#vectorbtpro.data.custom.GBMData),
which uses the [Geometric Brownian Motion](https://en.wikipedia.org/wiki/Geometric_Brownian_motion).
Both generators are very basic but still very interesting to test the models against. One weakness of them
is that real asset prices regularly make dramatic moves in response to new information. To account for this, 
we'll build a data generator based on the 
[LÃ©vy alpha-stable distribution](https://en.wikipedia.org/wiki/Stable_distribution)!

```pycon
>>> import vectorbtpro as vbt
>>> import numpy as np
>>> from scipy.stats import levy_stable

>>> def geometric_levy_price(alpha, beta, drift, vol, shape):  # (1)!
...     _rvs = levy_stable.rvs(alpha, beta,loc=0, scale=1, size=shape)
...     _rvs_sum = np.cumsum(_rvs, axis=0)
...     return np.exp(vol * _rvs_sum + (drift - 0.5 * vol ** 2))

>>> class LevyData(vbt.RandomData):  # (2)!
...     @classmethod
...     def generate_symbol(cls, symbol, index, num_paths=1, 
...                         start_value=100., alpha=1.68, beta=0.01, 
...                         drift=0.0, vol=0.01, seed=None):
...         if seed is not None:
...             np.random.seed(seed)
...         shape = (len(index), num_paths)
...         out = geometric_levy_price(alpha, beta, drift, vol, shape)
...         out = start_value * out
...
...         # (3)!
...         if out.shape[1] == 1:
...             return pd.Series(out[:, 0], index=index)
...         columns = pd.RangeIndex(stop=out.shape[1], name="path")
...         return pd.DataFrame(out, index=index, columns=columns)
```

1. Generation function, see [Asset price mimicry](https://medium.com/codex/generating-synthetic-price-data-2dd1e82fe5cf)
2. Subclass [RandomData](/api/data/custom/#vectorbtpro.data.custom.RandomData), which knows
how to update data classes that take `start_value` and `seed`
3. Convert the NumPy array into a Pandas object

Let's try it out by generating and plotting several columns of data:

```pycon
>>> levy_data = LevyData.fetch(
...     num_paths=3, 
...     start='2020-01-01 UTC', 
...     end='2021-01-01 UTC',
...     seed=42)
>>> levy_data.get()
path                                0           1           2
2020-01-01 00:00:00+00:00   98.909191  103.666348  101.748529
2020-01-02 00:00:00+00:00   99.906583  102.760336  100.433680
2020-01-03 00:00:00+00:00   97.096860  104.800667  100.689259
2020-01-04 00:00:00+00:00   98.379306  102.536030  102.573019
2020-01-05 00:00:00+00:00   99.855061  101.126850  101.045615
...                               ...         ...         ...
2020-12-28 00:00:00+00:00  235.699864   94.959570   52.257779
2020-12-29 00:00:00+00:00  233.743033   98.389358   52.680365
2020-12-30 00:00:00+00:00  234.951901   98.414794   52.104225
2020-12-31 00:00:00+00:00  231.853120   96.599117   51.366921
2021-01-01 00:00:00+00:00  234.277139   95.315039   50.834732

[367 rows x 3 columns]

>>> levy_data.get().vbt.plot()
```

![](/assets/images/synthetic_levy_data.svg)

Well done! We've built our own data mimicker that simulates sudden large changes in price.
